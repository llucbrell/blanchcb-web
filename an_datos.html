<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación de Visitantes en Museo</title>
    <!-- Tailwind CSS CDN para un estilo moderno y responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Un gris muy claro, casi blanco */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .main-simulation-container {
            /* Contenedor principal de la simulación, que contendrá controles y canvas */
            display: flex;
            flex-direction: column;
            gap: 2rem;
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%; /* Take full width of its parent (section) */
            max-width: 1200px; /* Max width for larger screens */
            margin: 2rem auto; /* Centrar y añadir margen superior/inferior */
        }
        @media (min-width: 768px) {
            .main-simulation-container {
                flex-direction: row;
            }
        }
        .controls-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .canvas-container {
            flex: 2;
            min-height: 400px; /* Altura mínima para el canvas */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e0e0e0; /* Fondo si la imagen no carga */
            border-radius: 0.75rem;
            overflow: hidden;
            position: relative; /* Para posicionar el fondo */
        }
        canvas {
            display: block;
            border-radius: 0.75rem;
            /* La anchura y altura del elemento HTML son gestionadas por JS para responsividad,
               pero se asegura que ocupe el 100% de su espacio disponible manteniendo el aspecto. */
            width: 100%;
            height: auto;
        }
        #simulationCanvas {
            background-color: #f8f8f8; /* Color de fondo si la imagen no carga */
        }
        /* Estilos para el nuevo contenedor del mapa de calor */
        .heatmap-container {
            width: 100%;
            max-width: 1200px;
            margin: 2rem auto;
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center; /* Centra el canvas dentro de este contenedor */
        }
        #heatmapCanvas {
            background-color: #f8f8f8; /* Color de fondo para el canvas del mapa de calor */
            border: 1px solid #ddd;
            border-radius: 0.75rem;
            margin-top: 1rem;
        }

        .control-group {
            @apply p-4 bg-orange-50 rounded-lg shadow-inner; /* Usar bg-orange-50 para consistencia */
        }
        label {
            @apply block text-sm font-medium text-gray-700 mb-1;
        }
        input[type="text"],
        input[type="color"],
        select {
            @apply mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm; /* Cambiar a orange-500 */
        }
        input[type="range"] {
            @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer;
        }
        button {
            @apply px-4 py-2 rounded-md font-semibold transition-colors duration-200;
        }
        button.primary {
            @apply bg-orange-600 text-white hover:bg-orange-700 shadow-md; /* Cambiar a naranja */
        }
        button.success {
            @apply bg-green-600 text-white hover:bg-green-700 shadow-md; /* Mantener verde para "éxito" */
        }
        button.danger {
            @apply bg-red-600 text-white hover:bg-red-700 shadow-md; /* Mantener rojo para "peligro/parar" */
        }
        button.secondary { /* New style for secondary actions like clear */
            @apply bg-gray-400 text-white hover:bg-gray-500 shadow-md;
        }
        .status-message {
            @apply mt-4 p-3 bg-orange-100 text-orange-800 rounded-md text-sm; /* Cambiar a naranja */
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Posición el tooltip arriba del texto */
            left: 50%;
            margin-left: -100px; /* Usa la mitad del ancho para centrar */
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        /* New style for the single stacked bar chart */
        #perRoomStackedBarChart, #satisfactionChart {
            width: 100%;
            max-width: 600px; /* Adjust max-width as needed */
            height: 350px; /* Adjust height as needed */
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <header class="bg-orange-700 text-white p-6 shadow-lg rounded-b-lg">
        <div class="container mx-auto flex justify-center items-center">
            <h1 class="text-3xl font-bold text-center">Simulación de Visitantes en el Museo</h1>
        </div>
    </header>

    <main class="flex-grow w-full flex justify-center items-center py-8 flex-col">
        <section id="agent-simulation-section" class="w-full">
            <div class="mb-8 p-4 bg-orange-50 rounded-md shadow-sm">

            <h1 class="text-3xl font-bold text-orange-800 mb-6 border-b-2 border-orange-400 pb-2 text-center">
                Simulación de Visitantes en el Museo (IVAM)
            </h1>
            <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                Observa cómo los "visitantes" (visitantes) se mueven por las salas del museo. Puedes añadir diferentes tipos de visitantes con distintos comportamientos y ver su interacción con el espacio delimitado.
            </p>
<p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
    Encontrarás un grupo de visitantes ya creado por defecto, puedes animarlo símplemente pulsando sobre empezar simulación, y detenerla cuando ya creas que ha pasado el suficiente tiempo, luego genera las gráficas y comprueba la analítica de datos.
</p>
                <div class="canvas-container">
                    <canvas id="simulationCanvas"></canvas>
                </div>
            <div class="main-simulation-container">
              
                <div class="controls-section">
                    <div class="control-group">
                        <h2 class="text-xl font-semibold text-gray-700 mb-3">Añadir Nuevo Agente</h2>
                        <div class="mb-3">
                            <label for="agentType">Tipo Agente:</label>
                            <input type="text" id="agentType" placeholder="Ej. Visitante, Guía">
                        </div>
                        <div class="mb-3">
                            <label for="agentColor">Color:</label>
                            <input type="color" id="agentColor" value="#1f77b4">
                        </div>
                        <div class="mb-3">
                            <label for="agentSpeed" class="flex justify-between items-center">
                                Velocidad:
                                <span id="speedValue" class="text-gray-600 text-sm">1.0</span>
                            </label>
                            <input type="range" id="agentSpeed" min="0.5" max="5.0" step="0.1" value="1.0">
                        </div>
                        <div class="mb-3">
                            <label for="agentBehavior">Comportamiento:</label>
                            <select id="agentBehavior">
                               <!--
                                <option value="random">Aleatorio (Rebota en paredes)</option>
                                <option value="walk_x">Caminar Horizontal</option>
                                <option value="walk_y">Caminar Vertical</option>
                            -->
                                <option value="random_with_stops">Aleatorio con Paradas</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="initialRoom">Sala Inicial:</label>
                            <select id="initialRoom">
                                <!-- Las opciones se generarán con JavaScript -->
                            </select>
                            <div class="tooltip mt-1 text-xs text-gray-500">
                                Los visitantes se generarán en la sala seleccionada.
                                <span class="tooltiptext">Define la sala de inicio del agente. Los visitantes permanecerán dentro de los límites de esta sala.</span>
                            </div>
                        </div>
                        <button id="addAgentBtn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full">Añadir Agente</button>
                                            <div id="statusMessage" class="status-message hidden"></div>

                    </div>

                    <div class="control-group">
                        <h2 class="text-xl font-semibold text-gray-700 mb-3">Controles de Simulación</h2>
                        <div class="flex flex-col sm:flex-row gap-4 mb-4">
                            <button id="startSimulationBtn" class="flex-1 bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full">Iniciar Simulación</button>
                            <button id="stopSimulationBtn" class="flex-1 bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full">Detener Simulación</button>
                        </div>
                        <button id="clearSimulationBtn" class="w-full bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-full mb-4">Limpiar Simulador</button>
                     
                        <button id="extractDataBtn" style="visibility: hidden;" class="w-full primary mb-4">Extraer Datos de Paradas (Consola)</button>
                    </div>

                    <div class="control-group">
                        <h2 class="text-xl font-semibold text-gray-700 mb-3">Visitantes Activos</h2>
                        <ul id="agentList" class="text-sm text-gray-700">
                            <!-- La lista de visitantes se actualizará aquí -->
                            <li class="text-gray-500">No hay visitantes añadidos.</li>
                        </ul>
                    </div>
                </div>
  
              
            </div>

            <!-- Sección para las gráficas y el nuevo mapa de calor -->
            <div class="mb-8 p-4 bg-orange-50 rounded-md shadow-sm">
                <h2 class="text-3xl text-center font-semibold text-orange-700 mb-4">Estadísticas</h2>
                <div class="responsive-media">
                    <!-- Sección para la gráfica global de tipos de visitantes -->
                    <div class="control-group">
                        <h2 class="text-xl text-center font-semibold text-gray-700 mb-3">Distribución Global de visitantes</h2>
                       <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                        Datos demográficos del porcentaje total de visitantes a museo.
                                          </p>
  
                        <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                        <button id="generateGlobalChartBtn" class="bg-blue-500  hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full mb-4">Generar Gráfica de Tipos Global</button>  
                    </p>
                       <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">

                                            <div id="globalChartStatus" class="mt-4 p-2 bg-blue-100 text-blue-800 rounded-md text-sm hidden"></div>
                    </p>

                        <div class="w-full max-w-sm mx-auto">
                            <canvas id="globalAgentTypeChart"></canvas>
                        </div>
                    </div>

                    <!-- Nueva sección para la única gráfica de barras apiladas por sala -->
                    <div class="control-group">                       
                        <h2 class="text-xl text-center font-semibold text-gray-700 mb-3">Distribución de Visitantes por Sala (Apilada)</h2>
                        <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                        Porcentaje de visitantes por sala
                         </p>
                        <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">

                        <button id="generatePerRoomChartsBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full">Generar Gráficas por Salas</button> <!-- Botón para gráficas de sala -->
                        </p>
                        <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                        <div id="perRoomChartStatus" class="mt-4 p-2 bg-blue-100 text-blue-800 rounded-md text-sm hidden">
                            Pulsa 'Generar Gráficas por Salas' para ver la distribución.
                        </div>
                                                </p>

                        <div class="w-full max-w-lg mx-auto"> <!-- Adjust width as needed for this chart -->
                            <canvas id="perRoomStackedBarChart"></canvas>
                        </div>
                        
                    </div>

                    <!-- Nueva sección para la gráfica de índice de satisfacción por sala -->
                    <div class="control-group">
                        
                        <h2 class="text-xl font-semibold text-center text-gray-700 mb-3">Índice de Satisfacción por Sala</h2>
                        <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                        Nivel de satisfacción extraído de los visitantes en función de sus reacciones en cada parada de la simulación.
                        </p>
                        <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                        <button id="generateSatisfactionChartBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full">Generar Gráfica de Satisfacción</button>

                        </p>
                        <div class="w-full max-w-lg mx-auto">
                            <canvas id="satisfactionChart"></canvas>
                        </div>
                        <div id="satisfactionChartStatus" class="mt-4 p-2 bg-blue-100 text-blue-800 rounded-md text-sm hidden">
                            Pulsa 'Generar Gráfica de Satisfacción' para ver los datos.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Nuevo contenedor para el mapa de calor -->
            <div class="heatmap-container">
                <h2 class="text-xl font-semibold text-gray-700 mb-3">Mapa de Calor (Tiempo de Permanencia)</h2>
                <p class="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
                    Lugares del museo en los que los visitantes se detubieron durante más tiempo.
                </p>
                <button id="generateHeatmapBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full">Generar Mapa de Calor</button>
                <div id="heatmapStatus" class="mt-4 p-2 bg-blue-100 text-blue-800 rounded-md text-sm hidden">
                    Pulsa 'Generar Mapa de Calor' para ver las zonas de mayor permanencia.
                </div>
                <canvas id="heatmapCanvas"></canvas> <!-- Nuevo canvas para el mapa de calor -->
            </div>
        </section>
    </main>

    <footer class="bg-orange-700 text-white p-6 mt-8 rounded-t-lg">
        <div class="container mx-auto text-center">
            <p>&copy; 2025 Blanca Cerveró Beltrán</p>
            <p class="text-sm mt-2"></p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // --- Configuración del Canvas y la Simulación ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        
        // Nuevo canvas para el mapa de calor
        const heatmapCanvas = document.getElementById('heatmapCanvas');
        const ctxHeatmap = heatmapCanvas.getContext('2d');

        // Constantes para el nuevo comportamiento "random_with_stops"
        const STOP_MIN_SECONDS = 0.5; // Minimum stop duration in seconds
        const STOP_MAX_SECONDS = 2.0; // Maximum stop duration in seconds
        const MOVE_MIN_SECONDS = 2.0; // Minimum move duration in seconds
        const MOVE_MAX_SECONDS = 5.0; // Maximum move duration in seconds
        const FPS = 60; // Approximate frames per second for requestAnimationFrame

        // Ruta de la imagen de la planta del museo (PLACEHOLDER)
        // Por favor, reemplaza esta URL con la imagen real de tu planta de museo.
        const MUSEUM_FLOOR_PLAN_IMAGE_URL = './assets/Planta_B-1.png'; // Make sure this path is correct
        const museumImage = new Image();
        museumImage.src = MUSEUM_FLOOR_PLAN_IMAGE_URL;

        let agents = []; // Lista para almacenar todos los objetos Agente
        let simulationRunning = false; // Bandera para controlar si la simulación está activa
        let animationFrameId = null; // ID del requestAnimationFrame para detenerlo
        let agentIdCounter = 0; // Contador para asignar IDs únicos a los visitantes

        // Variables para almacenar las dimensiones naturales de la imagen
        let imageNaturalWidth = 0;
        let imageNaturalHeight = 0;

        // Variables para la escala y offset del canvas de SIMULACIÓN
        let displayScale = 1; // Factor de escala de las coordenadas de la imagen original a las del canvas de simulación
        let displayOffsetX = 0; // Desplazamiento X para centrar la imagen en el canvas de simulación
        let displayOffsetY = 0; // Desplazamiento Y para centrar la imagen en el canvas de simulación

        // Variables para la escala y offset del canvas del MAPA DE CALOR
        let heatmapDisplayScale = 1; // Factor de escala para el canvas del mapa de calor
        let heatmapDisplayOffsetX = 0; // Desplazamiento X para el canvas del mapa de calor
        let heatmapDisplayOffsetY = 0; // Desplazamiento Y para el canvas del mapa de calor

        let globalAgentTypeChartInstance = null; // Variable para almacenar la instancia de la gráfica global
        let perRoomStackedBarChartInstance = null; // Variable para almacenar la instancia de la gráfica de barras apiladas por sala
        let satisfactionChartInstance = null; // Variable para almacenar la instancia de la gráfica de satisfacción

        // Datos para el mapa de calor
        const HEATMAP_GRID_SIZE = 15; // Tamaño de cada celda de la cuadrícula del mapa de calor en píxeles (coordenadas de la imagen original)
        let heatmapData = {}; // {'gridX_gridY': totalDwellTime}
        let maxDwellTime = 0; // Para normalizar la opacidad del mapa de calor


        // --- Definición de Salas (Límites) del Museo ---
        // Estas son las "habitaciones" donde los visitantes se moverán.
        // Las coordenadas (x, y, width, height) aquí deben ser relativas a la resolución
        // original de la imagen de tu planta de museo.
        // Por ejemplo, si tu imagen es de 1200x800, un 'x: 50' significa 50 píxeles desde el borde izquierdo
        // de la imagen de 1200 píxeles de ancho.
        const rooms = [
            { id: 'sala2', name: 'G1', x: 177, y: 368, width: 420, height: 112 },
            { id: 'sala1', name: 'G2', x: 177, y: 210, width: 420, height: 112 },
            { id: 'sala5', name: 'G3', x: 721, y: 210, width: 112, height: 112 },
            { id: 'sala3', name: 'Vestíbulo', x: 610, y: 250, width: 100, height: 230 },
            { id: 'sala4', name: 'Cafetería', x: 721, y: 384, width: 112, height: 100 }
        ];

        // --- Clase Agente ---
        class Agent {
            constructor(id, agentType, color, speed, behaviorType, initialRoomId) {
                this.id = id;
                this.type = agentType;
                this.color = color; 
                this.speed = speed;
                this.behaviorType = behaviorType;
                this.currentRoom = rooms.find(room => room.id === initialRoomId);

                if (!this.currentRoom) {
                    console.error(`Sala inicial no encontrada para el agente: ${initialRoomId}. Asignando a Sala 1.`);
                    this.currentRoom = rooms[0]; // Fallback a la primera sala
                }

                // Posición inicial aleatoria dentro de la sala asignada (en el sistema de coordenadas de la imagen original)
                this.x = randomRange(this.currentRoom.x, this.currentRoom.x + this.currentRoom.width);
                this.y = randomRange(this.currentRoom.y, this.currentRoom.y + this.currentRoom.height);

                // Velocidad direccional inicial (para 'random' y 'random_with_stops')
                if (this.behaviorType === 'random' || this.behaviorType === 'random_with_stops') {
                    const angle = Math.random() * 2 * Math.PI;
                    this.vx = Math.cos(angle) * this.speed * 0.5;
                    this.vy = Math.sin(angle) * this.speed * 0.5;
                } else {
                    this.vx = 0; // Comportamientos walk_x/y ajustan velocidad en move()
                    this.vy = 0;
                }

                // Propiedades específicas para el comportamiento 'random_with_stops'
                if (this.behaviorType === 'random_with_stops') {
                    this.isStopped = false;
                    // Duraciones en "frames" para que la lógica de movimiento sea consistente con el pasado
                    this.moveDurationFrames = Math.floor(randomRange(MOVE_MIN_SECONDS, MOVE_MAX_SECONDS) * FPS);
                    this.stopDurationFrames = Math.floor(randomRange(STOP_MIN_SECONDS, STOP_MAX_SECONDS) * FPS);
                    this.currentActivityTimer = this.moveDurationFrames; // Empieza moviéndose
                }
                
                // --- Propiedades para la Extracción de Datos de Paradas ---
                this.stopData = []; // Array para almacenar los datos de cada parada
            }

            move() { // NO recibe deltaTime aquí para mantener la lógica que te funciona
                let deltaX = 0;
                let deltaY = 0;

                if (this.behaviorType === 'random_with_stops') {
                    this.currentActivityTimer--;

                    if (this.isStopped) {
                        // Agente está parado, no hay movimiento
                        if (this.currentActivityTimer <= 0) {
                            // Tiempo de parada terminado, empieza a moverse
                            this.isStopped = false;
                            // Recalcula la duración del movimiento para el siguiente ciclo
                            this.moveDurationFrames = Math.floor(randomRange(MOVE_MIN_SECONDS, MOVE_MAX_SECONDS) * FPS);
                            this.currentActivityTimer = this.moveDurationFrames;
                            
                            // Elige una nueva dirección aleatoria al comenzar a moverse
                            const angle = Math.random() * 2 * Math.PI;
                            this.vx = Math.cos(angle) * this.speed * 0.5;
                            this.vy = Math.sin(angle) * this.speed * 0.5;
                            deltaX = this.vx; // Mover en este mismo frame si ya se asignó nueva velocidad
                            deltaY = this.vy;
                        }
                    } else { // Agente se está moviendo
                        deltaX = this.vx;
                        deltaY = this.vy;

                        if (this.currentActivityTimer <= 0) {
                            // Tiempo de movimiento terminado, empieza a parar
                            this.isStopped = true;
                            // Recalcula la duración de la parada para el siguiente ciclo
                            this.stopDurationFrames = Math.floor(randomRange(STOP_MIN_SECONDS, STOP_MAX_SECONDS) * FPS);
                            this.currentActivityTimer = this.stopDurationFrames;
                            
                            // *** Registrar datos de la parada ***
                            const currentStopDuration = (this.stopDurationFrames / FPS);
                            this.stopData.push({
                                x: this.x.toFixed(2), // Coordenada X actual
                                y: this.y.toFixed(2), // Coordenada Y actual
                                duration: currentStopDuration.toFixed(2), // Duración real de la parada en segundos
                                satisfaction: (Math.random() * 9 + 1).toFixed(1) // Nivel de satisfacción aleatorio (1.0 a 10.0)
                            });

                            // Actualizar datos del mapa de calor
                            const gridX = Math.floor(this.x / HEATMAP_GRID_SIZE);
                            const gridY = Math.floor(this.y / HEATMAP_GRID_SIZE);
                            const cellKey = `${gridX}_${gridY}`;
                            heatmapData[cellKey] = (heatmapData[cellKey] || 0) + currentStopDuration;
                            
                            // Actualizar el tiempo máximo de permanencia
                            if (heatmapData[cellKey] > maxDwellTime) {
                                maxDwellTime = heatmapData[cellKey];
                            }

                            // El movimiento se detiene inmediatamente
                            deltaX = 0;
                            deltaY = 0;
                        }
                    }
                } else if (this.behaviorType === 'random') {
                    deltaX = this.vx;
                    deltaY = this.vy;
                } else if (this.behaviorType === 'walk_x') {
                    deltaX = this.speed * (Math.random() * 2 - 1); // Rango de -velocidad a +velocidad
                    deltaY = this.speed * (Math.random() * 0.2 - 0.1); // Pequeña desviación
                } else if (this.behaviorType === 'walk_y') {
                    deltaY = this.speed * (Math.random() * 2 - 1);
                    deltaX = this.speed * (Math.random() * 0.2 - 0.1);
                }

                let nextX = this.x + deltaX;
                let nextY = this.y + deltaY;

                // --- Lógica de Rebote en los Límites de la Sala (en el sistema de coordenadas de la imagen original) ---
                const room = this.currentRoom;

                // Rebote y ajuste en el eje X
                if (nextX < room.x) {
                    nextX = room.x;
                    if (this.behaviorType === 'random' || this.behaviorType === 'random_with_stops') {
                        this.vx *= -1; // Invertir velocidad interna para un rebote consistente
                    }
                } else if (nextX > room.x + room.width) {
                    nextX = room.x + room.width;
                    if (this.behaviorType === 'random' || this.behaviorType === 'random_with_stops') {
                        this.vx *= -1;
                    }
                }

                // Rebote y ajuste en el eje Y
                if (nextY < room.y) {
                    nextY = room.y;
                    if (this.behaviorType === 'random' || this.behaviorType === 'random_with_stops') {
                        this.vy *= -1;
                    }
                } else if (nextY > room.y + room.height) {
                    nextY = room.y + room.height;
                    if (this.behaviorType === 'random' || this.behaviorType === 'random_with_stops') {
                        this.vy *= -1;
                    }
                }

                // Actualizar la posición final del agente
                this.x = nextX;
                this.y = nextY;

                // Asegurar que el agente esté estrictamente dentro de los límites después de todos los cálculos (seguro adicional)
                this.x = Math.max(room.x, Math.min(this.x, room.x + room.width));
                this.y = Math.max(room.y, Math.min(this.y, room.y + room.height));
            }

            draw() {
                // Convertir la posición del agente del sistema de coordenadas de la imagen original al canvas
                const canvasX = this.x * displayScale + displayOffsetX;
                const canvasY = this.y * displayScale + displayOffsetY;

                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 5 * displayScale, 0, Math.PI * 2); // Escalar el tamaño del punto también
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        }

        // --- Funciones Auxiliares ---
        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function updateAgentListUI() {
            const agentListElement = document.getElementById('agentList');
            agentListElement.innerHTML = ''; // Limpiar lista existente
            if (agents.length === 0) {
                agentListElement.innerHTML = '<li class="text-gray-500">No hay visitantes añadidos.</li>';
                return;
            }
            agents.forEach(agent => {
                const li = document.createElement('li');
                // Estilizar el puntito en la lista con el color del agente
                li.innerHTML = `<span style="color:${agent.color}; display:inline-block; width:10px; height:10px; border-radius:50%; background-color:${agent.color}; margin-right:5px; vertical-align:middle;"></span> ID: ${agent.id}, Tipo: ${agent.type}, Sala: ${agent.currentRoom.name}, Vel: ${agent.speed.toFixed(1)}`;
                agentListElement.appendChild(li);
            });
        }

        function showStatusMessage(message, type = 'info') {
            const statusElement = document.getElementById('statusMessage');
            statusElement.textContent = message;
            statusElement.classList.remove('hidden', 'bg-orange-100', 'text-orange-800', 'bg-red-100', 'text-red-800');
            if (type === 'info') {
                statusElement.classList.add('bg-orange-100', 'text-orange-800');
            } else if (type === 'error') {
                statusElement.classList.add('bg-red-100', 'text-red-800');
            }
            statusElement.classList.remove('hidden');
            setTimeout(() => {
                statusElement.classList.add('hidden');
            }, 3000); // Ocultar después de 3 segundos
        }

        // --- Funciones de Dibujo del Canvas ---
        // Ahora acepta parámetros para escala y offset para mayor flexibilidad
        function drawMuseumMap(targetCtx, targetCanvas, scale, offsetX, offsetY) {
            targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height); // Limpiar el canvas antes de dibujar el fondo

            // Dibuja la imagen de fondo de la planta del museo
            if (museumImage.complete && imageNaturalWidth > 0) {
                // Dibujar la imagen escalada usando los parámetros proporcionados
                targetCtx.drawImage(museumImage, offsetX, offsetY,
                              imageNaturalWidth * scale, imageNaturalHeight * scale);
            } else {
                // Si la imagen no está cargada o es inválida, usa un color de fondo sólido
                targetCtx.fillStyle = '#f0f0f0';
                targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
                targetCtx.fillStyle = '#555555';
                targetCtx.font = '20px Inter';
                targetCtx.textAlign = 'center';
                targetCtx.fillText('Cargando planta del museo...', targetCanvas.width / 2, targetCanvas.height / 2);
            }

            // Dibuja los límites de las salas (opcional, para depuración y visualización)
            rooms.forEach(room => {
                const scaledX = room.x * scale + offsetX;
                const scaledY = room.y * scale + offsetY;
                const scaledWidth = room.width * scale;
                const scaledHeight = room.height * scale;

                targetCtx.strokeStyle = 'rgba(255, 165, 0, 0.7)'; /* Naranja semitransparente */
                targetCtx.lineWidth = 2;
                targetCtx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
                targetCtx.fillStyle = 'rgba(120, 50, 0, 0.8)'; /* Naranja oscuro para el texto */
                targetCtx.font = `bold ${Math.max(10, 14 * scale)}px Inter`; /* Escalar fuente, mínimo 10px */
                targetCtx.fillText(room.name, scaledX + 5, scaledY + 20);
            });
        }

        function drawSimulation() {
            // Usa las variables globales de escala y offset para el canvas principal
            drawMuseumMap(ctx, canvas, displayScale, displayOffsetX, displayOffsetY);
            agents.forEach(agent => agent.draw()); // Dibujar todos los visitantes
        }

        // --- Bucle de Simulación ---
        function simulationLoop() {
            if (!simulationRunning) {
                return;
            }
            
            agents.forEach(agent => agent.move());
            drawSimulation(); // Redibujar todo el canvas con las nuevas posiciones

            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        // --- Funciones para Gráficos ---

        // Función para la gráfica global de tipos de visitantes (Doughnut Chart)
        function generateGlobalAgentTypeChart() {
            const agentTypeCounts = {};
            const agentTypeColorsMap = {}; // Map specific agent types to their colors

            agents.forEach(agent => {
                agentTypeCounts[agent.type] = (agentTypeCounts[agent.type] || 0) + 1;
                agentTypeColorsMap[agent.type] = agent.color; // Store the color for this specific type
            });

            const agentTypeLabels = Object.keys(agentTypeCounts);
            const data = agentTypeLabels.map(label => agentTypeCounts[label]);
            const agentTypeColors = agentTypeLabels.map(label => agentTypeColorsMap[label]); // Get colors based on collected types

            const globalChartStatus = document.getElementById('globalChartStatus');

            if (agents.length === 0) {
                if (globalAgentTypeChartInstance) {
                    globalAgentTypeChartInstance.destroy();
                    globalAgentTypeChartInstance = null;
                }
                globalChartStatus.textContent = "Añade visitantes para ver el gráfico de distribución global.";
                globalChartStatus.classList.remove('hidden');
                return;
            }

            globalChartStatus.classList.add('hidden'); // Oculta el mensaje si hay datos

            const ctxGlobalChart = document.getElementById('globalAgentTypeChart').getContext('2d');

            if (globalAgentTypeChartInstance) {
                // Actualizar la gráfica existente
                globalAgentTypeChartInstance.data.labels = agentTypeLabels;
                globalAgentTypeChartInstance.data.datasets[0].data = data;
                globalAgentTypeChartInstance.data.datasets[0].backgroundColor = agentTypeColors;
                globalAgentTypeChartInstance.update();
            } else {
                // Crear una nueva gráfica
                globalAgentTypeChartInstance = new Chart(ctxGlobalChart, {
                    type: 'doughnut',
                    data: {
                        labels: agentTypeLabels,
                        datasets: [{
                            label: 'Porcentaje de Visitantes por Tipología',
                            data: data,
                            backgroundColor: agentTypeColors,
                            hoverOffset: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: 'Distribución Global de Visitantes por Tipología'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw;
                                        const total = context.dataset.data.reduce((sum, current) => sum + current, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        // Función para la gráfica de barras apiladas por sala
        function generatePerRoomStackedBarChart() {
            const perRoomChartStatus = document.getElementById('perRoomChartStatus');
            const ctxPerRoomChart = document.getElementById('perRoomStackedBarChart').getContext('2d');

            // Collect data: labels (room names) and datasets (agent types counts per room)
            const roomNames = rooms.map(room => room.name);
            const uniqueAgentTypes = [...new Set(agents.map(agent => agent.type))]; // Get all unique agent types present
            const uniqueAgentTypeColorsMap = {};
            agents.forEach(agent => {
                uniqueAgentTypeColorsMap[agent.type] = agent.color; // Map type to its color
            });


            const datasets = uniqueAgentTypes.map(type => {
                const dataForType = rooms.map(room => {
                    const agentsInRoomOfType = agents.filter(agent => 
                        agent.currentRoom.id === room.id && agent.type === type
                    ).length;
                    return agentsInRoomOfType;
                });
                return {
                    label: type,
                    data: dataForType,
                    backgroundColor: uniqueAgentTypeColorsMap[type], // Use the color from the map
                    stack: 'roomStack' // All datasets share the same stack name for stacking
                };
            });

            // Calculate totals per room for percentage calculation in tooltips
            // This array is not strictly needed anymore for the tooltip, but kept if other parts might use it.
            const totalsPerRoom = rooms.map(room => {
                return agents.filter(agent => agent.currentRoom.id === room.id).length;
            });

            if (agents.length === 0) {
                if (perRoomStackedBarChartInstance) {
                    perRoomStackedBarChartInstance.destroy();
                    perRoomStackedBarChartInstance = null;
                }
                perRoomChartStatus.textContent = "Añade visitantes para ver las gráficas de distribución por sala.";
                perRoomChartStatus.classList.remove('hidden');
                return;
            }

            perRoomChartStatus.classList.add('hidden'); // Oculta el mensaje si hay datos

            if (perRoomStackedBarChartInstance) {
                // Update existing chart
                perRoomStackedBarChartInstance.data.labels = roomNames;
                perRoomStackedBarChartInstance.data.datasets = datasets;
                perRoomStackedBarChartInstance.update();
            } else {
                // Create new chart
                perRoomStackedBarChartInstance = new Chart(ctxPerRoomChart, {
                    type: 'bar',
                    data: {
                        labels: roomNames,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, // Allow custom height for better bar display
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: 'Distribución de Visitantes por Tipología en Cada Sala'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.dataset.label || '';
                                        const value = context.raw; // Value of the current segment (e.g., count of 'Visitante 15-29' in 'G1')
                                        const roomIndex = context.dataIndex; // Index of the room (bar)
                                        
                                        // Recalculate total for this specific room's bar from all datasets
                                        let totalInThisBar = 0;
                                        context.chart.data.datasets.forEach(dataset => {
                                            totalInThisBar += dataset.data[roomIndex] || 0;
                                        });

                                        const percentage = totalInThisBar > 0 ? ((value / totalInThisBar) * 100).toFixed(1) : 0;
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Sala del Museo'
                                }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Número de Visitantes'
                                },
                                // Optionally, if you want the Y-axis to display percentage based on total in room
                                // This requires a custom tick formatter and careful calculation
                                ticks: {
                                    callback: function(value, index, values) {
                                        // This callback is for the Y-axis tick labels.
                                        // It's tricky to show percentage on stacked bars if the total for each bar varies.
                                        // Keeping it as raw count for now.
                                        return value;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        // Nueva función para la gráfica de índice de satisfacción por sala
        function generateSatisfactionChart() {
            const satisfactionChartStatus = document.getElementById('satisfactionChartStatus');
            const ctxSatisfactionChart = document.getElementById('satisfactionChart').getContext('2d');

            const roomSatisfactionData = {}; // { roomId: { totalSatisfaction: 0, stopCount: 0 } }

            // Initialize room data
            rooms.forEach(room => {
                roomSatisfactionData[room.id] = { totalSatisfaction: 0, stopCount: 0 };
            });

            // Populate satisfaction data from agents' stopData
            agents.forEach(agent => {
                if (agent.behaviorType === 'random_with_stops' && agent.stopData.length > 0) {
                    const room = agent.currentRoom;
                    // Ensure the room exists in roomSatisfactionData before adding stops
                    if (roomSatisfactionData[room.id]) { 
                        agent.stopData.forEach(stop => {
                            roomSatisfactionData[room.id].totalSatisfaction += parseFloat(stop.satisfaction);
                            roomSatisfactionData[room.id].stopCount++;
                        });
                    }
                }
            });

            const labels = rooms.map(room => room.name);
            const data = rooms.map(room => {
                const roomStats = roomSatisfactionData[room.id];
                return roomStats.stopCount > 0 ? (roomStats.totalSatisfaction / roomStats.stopCount).toFixed(2) : 0;
            });
            const backgroundColors = data.map(avgSat => {
                // Basic color scale from red (low) to green (high) satisfaction
                const value = parseFloat(avgSat);
                if (value >= 8) return '#4CAF50'; // Green
                if (value >= 6) return '#8BC34A'; // Light Green
                if (value >= 4) return '#FFEB3B'; // Yellow
                if (value >= 2) return '#FFC107'; // Amber
                return '#F44336'; // Red
            });

            if (agents.filter(agent => agent.behaviorType === 'random_with_stops').length === 0 || data.every(val => val === 0)) {
                if (satisfactionChartInstance) {
                    satisfactionChartInstance.destroy();
                    satisfactionChartInstance = null;
                }
                satisfactionChartStatus.textContent = "Añade visitantes y/o genera datos de la simulación para ver esta gráfica.";
                satisfactionChartStatus.classList.remove('hidden');
                return;
            }

            satisfactionChartStatus.classList.add('hidden'); // Oculta el mensaje si hay datos

            if (satisfactionChartInstance) {
                satisfactionChartInstance.data.labels = labels;
                satisfactionChartInstance.data.datasets[0].data = data;
                satisfactionChartInstance.data.datasets[0].backgroundColor = backgroundColors;
                satisfactionChartInstance.update();
            } else {
                satisfactionChartInstance = new Chart(ctxSatisfactionChart, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Índice de Satisfacción Promedio',
                            data: data,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors.map(color => color.replace('A', 'C')), // Slightly darker border
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false, // No legend needed for a single dataset
                            },
                            title: {
                                display: true,
                                text: 'Índice de Satisfacción Promedio por Sala (1-10)'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Satisfacción: ${context.raw}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Sala del Museo'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                max: 10, // Satisfaction scale from 1 to 10
                                title: {
                                    display: true,
                                    text: 'Satisfacción Promedio'
                                }
                            }
                        }
                    }
                });
            }
        }

        // Nueva función para generar el mapa de calor
        function generateHeatmap() {
            const heatmapStatus = document.getElementById('heatmapStatus');
            ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height); // Limpiar el canvas de calor

            // Dibujar el mapa del museo en el canvas del mapa de calor, usando sus propias escalas
            drawMuseumMap(ctxHeatmap, heatmapCanvas, heatmapDisplayScale, heatmapDisplayOffsetX, heatmapDisplayOffsetY);

            if (Object.keys(heatmapData).length === 0 || maxDwellTime === 0) {
                heatmapStatus.textContent = "Añade visitantes y/o genera datos de la simulación para ver esta gráfica.";
                heatmapStatus.classList.remove('hidden');
                return;
            }
            heatmapStatus.classList.add('hidden'); // Oculta el mensaje si hay datos

            // Dibujar los puntos de calor
            for (const cellKey in heatmapData) {
                const [gridX, gridY] = cellKey.split('_').map(Number);
                const dwellTime = heatmapData[cellKey];

                // Calcular la opacidad basada en el tiempo de permanencia normalizado
                const opacity = Math.min(1, Math.max(0.1, dwellTime / maxDwellTime)); // Min opacity to show even small values

                // Convertir las coordenadas de la cuadrícula a las coordenadas del canvas de calor
                // Asegúrate de que las coordenadas y el tamaño de la celda también se escalen con heatmapDisplayScale
                const canvasX = (gridX * HEATMAP_GRID_SIZE * heatmapDisplayScale) + heatmapDisplayOffsetX;
                const canvasY = (gridY * HEATMAP_GRID_SIZE * heatmapDisplayScale) + heatmapDisplayOffsetY;
                const scaledCellSize = HEATMAP_GRID_SIZE * heatmapDisplayScale;

                ctxHeatmap.fillStyle = `rgba(255, 0, 0, ${opacity})`; // Rojo para el calor
                ctxHeatmap.fillRect(canvasX, canvasY, scaledCellSize, scaledCellSize);
            }
            showStatusMessage("Mapa de calor generado.", 'info');
        }


        // --- Gestión de Eventos UI ---
        document.getElementById('agentSpeed').addEventListener('input', (event) => {
            document.getElementById('speedValue').textContent = parseFloat(event.target.value).toFixed(1);
        });

        document.getElementById('addAgentBtn').addEventListener('click', () => {
            const agentType = document.getElementById('agentType').value.trim();
            const selectedColor = document.getElementById('agentColor').value;
            const agentSpeed = parseFloat(document.getElementById('agentSpeed').value);
            const agentBehavior = document.getElementById('agentBehavior').value;
            const initialRoomId = document.getElementById('initialRoom').value;

            if (!agentType) {
                showStatusMessage("Por favor, introduce un Tipo de Agente.", 'error');
                return;
            }
            if (!initialRoomId) {
                showStatusMessage("Por favor, selecciona una Sala Inicial.", 'error');
                return;
            }

            // Usar el color seleccionado del picker para visitantes nuevos
            const agentColor = selectedColor; 

            agentIdCounter++;
            const newAgent = new Agent(agentIdCounter, agentType, agentColor, agentSpeed, agentBehavior, initialRoomId);
            agents.push(newAgent);
            showStatusMessage(`Agente '${agentType}' (ID: ${agentIdCounter}) añadido.`);
            updateAgentListUI();
            drawSimulation(); // Dibuja el nuevo agente inmediatamente
        });

        document.getElementById('startSimulationBtn').addEventListener('click', () => {
            if (!simulationRunning) {
                if (agents.length === 0) {
                    showStatusMessage("Añade al menos un agente antes de iniciar la simulación.", 'error');
                    return;
                }
                simulationRunning = true;
                showStatusMessage("Simulación Iniciada...  Mire el mapa de la parte superior", 'info');
                simulationLoop(); // Iniciar el bucle de animación
            }
        });

        document.getElementById('stopSimulationBtn').addEventListener('click', () => {
            if (simulationRunning) {
                simulationRunning = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId); // Detener la animación
                }
                showStatusMessage("Simulación Detenida.", 'info');
            }
        });

        // --- Nuevo botón para limpiar el simulador ---
        document.getElementById('clearSimulationBtn').addEventListener('click', () => {
            if (simulationRunning) {
                simulationRunning = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
            }
            agents = []; // Vaciar la lista de visitantes
            agentIdCounter = 0; // Resetear el contador de IDs
            heatmapData = {}; // Limpiar datos del mapa de calor
            maxDwellTime = 0; // Resetear el tiempo máximo de permanencia
            ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height); // Limpiar el canvas de calor
            drawMuseumMap(ctxHeatmap, heatmapCanvas, heatmapDisplayScale, heatmapDisplayOffsetX, heatmapDisplayOffsetY); // Redibujar solo el mapa en el canvas de calor
            updateAgentListUI(); // Limpiar la lista en la UI
            drawSimulation(); // Redibujar el canvas sin visitantes
            showStatusMessage("Simulador limpiado.", 'info');
            
            // Destruir la gráfica global
            if (globalAgentTypeChartInstance) {
                globalAgentTypeChartInstance.destroy();
                globalAgentTypeChartInstance = null;
                document.getElementById('globalChartStatus').classList.remove('hidden');
                document.getElementById('globalChartStatus').textContent = "Pulsa 'Generar Gráfica de Tipos Global' para ver la distribución.";
            }

            // Destruir la gráfica de barras apiladas por sala
            if (perRoomStackedBarChartInstance) {
                perRoomStackedBarChartInstance.destroy();
                perRoomStackedBarChartInstance = null;
                document.getElementById('perRoomChartStatus').classList.remove('hidden');
                document.getElementById('perRoomChartStatus').textContent = "Pulsa 'Generar Gráficas por Salas' para ver la distribución.";
            }

            // Destruir la gráfica de satisfacción
            if (satisfactionChartInstance) {
                satisfactionChartInstance.destroy();
                satisfactionChartInstance = null;
                document.getElementById('satisfactionChartStatus').classList.remove('hidden');
                document.getElementById('satisfactionChartStatus').textContent = "Pulsa 'Generar Gráfica de Satisfacción' para ver los datos.";
            }

            // Resetear el estado del mapa de calor
            document.getElementById('heatmapStatus').classList.remove('hidden');
            document.getElementById('heatmapStatus').textContent = "Pulsa 'Generar Mapa de Calor' para ver las zonas de mayor permanencia.";
        });

        // --- Función para Extraer Datos de la Simulación (modificada) ---
        document.getElementById('extractDataBtn').addEventListener('click', () => {
            // Detener la simulación si está corriendo para asegurar datos finales consistentes
            if (simulationRunning) {
                document.getElementById('stopSimulationBtn').click(); // Simula clic en Detener
            }

            const stoppedAgentsData = agents
                .filter(agent => agent.behaviorType === 'random_with_stops')
                .map(agent => ({
                    agentId: agent.id,
                    agentType: agent.type,
                    agentColor: agent.color,
                    stops: agent.stopData // Ya contiene las paradas con x, y, duration y satisfaction
                }));

            // Imprimir el JSON a la consola
            console.log("--- Datos de Paradas de Visitantes (JSON) ---");
            console.log(JSON.stringify(stoppedAgentsData, null, 2));
            showStatusMessage("Datos de paradas extraídos a la consola. Abre la Consola del navegador (F12).", 'info');
        });

        // --- Botón para generar la gráfica global ---
        document.getElementById('generateGlobalChartBtn').addEventListener('click', () => {
            if (agents.length === 0) {
                showStatusMessage("Añade visitantes antes de generar la gráfica global.", 'error');
                return;
            }
            generateGlobalAgentTypeChart(); // Llama a la función para crear/actualizar la gráfica global
            showStatusMessage("Gráfica global de tipos de visitantes generada.", 'info');
        });

        // --- Botón para generar las gráficas por sala (Stacked Bar Chart) ---
        document.getElementById('generatePerRoomChartsBtn').addEventListener('click', () => {
            if (agents.length === 0) {
                showStatusMessage("Añade visitantes antes de generar las gráficas por salas.", 'error');
                return;
            }
            generatePerRoomStackedBarChart(); // Llama a la función para crear/actualizar la gráfica de barras apiladas
            showStatusMessage("Gráfica de distribución por sala generada.", 'info');
        });

        // --- Botón para generar la gráfica de satisfacción por sala ---
        document.getElementById('generateSatisfactionChartBtn').addEventListener('click', () => {
            if (agents.filter(agent => agent.behaviorType === 'random_with_stops').length === 0) {
                showStatusMessage("Añade visitantes con comportamiento 'Aleatorio con Paradas' para generar la gráfica de satisfacción.", 'error');
                return;
            }
            generateSatisfactionChart(); // Llama a la nueva función para crear/actualizar la gráfica de satisfacción
            showStatusMessage("Gráfica de índice de satisfacción por sala generada.", 'info');
        });

        // --- Botón para generar el mapa de calor ---
        document.getElementById('generateHeatmapBtn').addEventListener('click', () => {
            // Asegurarse de que el heatmapData esté actualizado antes de generar el mapa
            // No hay una actualización explícita aquí, se actualiza en agent.move()
            // Si la simulación está parada y no se han movido visitantes con paradas, el mapa estará vacío
            generateHeatmap(); // Llama a la función para generar el mapa de calor
        });


        // --- Inicialización ---
        window.onload = () => {
            // Ajustar el tamaño del canvas al contenedor (y por lo tanto, responsivo)
            const canvasContainer = document.querySelector('.canvas-container');
            const heatmapContainer = document.querySelector('.heatmap-container'); // Nuevo contenedor para el mapa de calor

            // Función para configurar el tamaño del canvas y calcular la escala de la imagen
            const setCanvasSize = () => {
                if (!museumImage.complete || museumImage.naturalWidth === 0) {
                    // La imagen aún no está cargada o es inválida. Establecer tamaños de fallback y salir.
                    canvas.width = canvas.parentElement.clientWidth;
                    canvas.height = 400; 
                    heatmapCanvas.width = heatmapCanvas.parentElement.clientWidth;
                    heatmapCanvas.height = 400;
                    drawMuseumMap(ctx, canvas, 1, 0, 0); // Dibujar fallback para el principal
                    drawMuseumMap(ctxHeatmap, heatmapCanvas, 1, 0, 0); // Dibujar fallback para el mapa de calor
                    return;
                }

                imageNaturalWidth = museumImage.naturalWidth;
                imageNaturalHeight = museumImage.naturalHeight;
                const imageAspectRatio = imageNaturalWidth / imageNaturalHeight;

                // --- Tamaño del Canvas de Simulación Principal ---
                const simContainerWidth = canvasContainer.clientWidth;
                const simContainerHeight = canvasContainer.clientHeight;
                
                // Establecer la resolución interna del canvas de simulación para que coincida con su contenedor visible
                canvas.width = simContainerWidth;
                canvas.height = simContainerHeight;

                // Calcular la escala y los offsets para dibujar la imagen del museo *dentro* de este canvas principal
                let imgScaledWidth, imgScaledHeight;
                const canvasAspectRatio = canvas.width / canvas.height;

                if (imageAspectRatio > canvasAspectRatio) {
                    // La imagen es más ancha con respecto a su altura que el canvas. Ajustar por el ancho del canvas.
                    imgScaledWidth = canvas.width;
                    imgScaledHeight = canvas.width / imageAspectRatio;
                } else {
                    // La imagen es más alta con respecto a su ancho que el canvas. Ajustar por la altura del canvas.
                    imgScaledHeight = canvas.height;
                    imgScaledWidth = canvas.height * imageAspectRatio;
                }
                
                displayScale = imgScaledWidth / imageNaturalWidth;
                displayOffsetX = (canvas.width - imgScaledWidth) / 2;
                displayOffsetY = (canvas.height - imgScaledHeight) / 2;

                // --- Tamaño del Canvas del Mapa de Calor ---
                const heatmapContainerWidth = heatmapContainer.clientWidth;
                
                // El canvas del mapa de calor debe tener una resolución interna que coincida con la relación de aspecto de la imagen
                // y se ajuste al ancho de su contenedor.
                const effectiveHeatmapCanvasWidth = heatmapContainerWidth;
                const effectiveHeatmapCanvasHeight = heatmapContainerWidth / imageAspectRatio;

                heatmapCanvas.width = effectiveHeatmapCanvasWidth;
                heatmapCanvas.height = effectiveHeatmapCanvasHeight;

                // Para el dibujo del mapa en el canvas de calor, la escala es la que ajusta la imagen original al tamaño interno del canvas.
                // Como el canvas.width y canvas.height ya se han ajustado para mantener el aspecto y llenar el ancho,
                // la escala será 1 y los offsets 0 si la imagen se dibuja directamente en este canvas interno.
                heatmapDisplayScale = effectiveHeatmapCanvasWidth / imageNaturalWidth; // Esto debería ser 1 si heatmapCanvas.width ya es la imagen Natural Ancho
                heatmapDisplayOffsetX = 0; 
                heatmapDisplayOffsetY = 0; 
                
                drawSimulation(); // Utiliza displayScale, displayOffsetX/Y para el canvas principal
                
                // Vuelve a dibujar el fondo del mapa de calor al cambiar el tamaño, y luego la superposición de calor
                drawMuseumMap(ctxHeatmap, heatmapCanvas, heatmapDisplayScale, heatmapDisplayOffsetX, heatmapDisplayOffsetY);
                
                if (Object.keys(heatmapData).length > 0 && maxDwellTime > 0) {
                     generateHeatmap();
                }
            };

            // Observar cambios de tamaño en el contenedor principal para ajustar el canvas
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === canvasContainer || entry.target === heatmapContainer) {
                        setCanvasSize();
                    }
                }
            });
            resizeObserver.observe(canvasContainer);
            resizeObserver.observe(heatmapContainer);


            // Cargar imagen del museo y redibujar cuando esté lista
            museumImage.onload = () => {
                setCanvasSize(); // Vuelve a calcular el tamaño y escala del canvas una vez cargada la imagen
                // --- Añadir visitantes por defecto después de que la imagen se haya cargado y escalado ---
                addDefaultAgents();
            };
            // Si la imagen ya está en caché o se carga rápidamente, asegurar que se dibuje
            if (museumImage.complete) {
                setCanvasSize();
                addDefaultAgents(); // Añadir visitantes por defecto si la imagen ya está cargada
            } else {
                // Mostrar un mensaje de carga si la imagen tarda
                drawMuseumMap(ctx, canvas, displayScale, displayOffsetX, displayOffsetY);
                drawMuseumMap(ctxHeatmap, heatmapCanvas, heatmapDisplayScale, heatmapDisplayOffsetX, heatmapDisplayOffsetY); // También en el canvas de calor
            }


            // Llenar el selector de salas
            const initialRoomSelect = document.getElementById('initialRoom');
            rooms.forEach(room => {
                const option = document.createElement('option');
                option.value = room.id;
                option.textContent = room.name;
                initialRoomSelect.appendChild(option);
            });

            updateAgentListUI(); // Mostrar lista de visitantes vacía al inicio
            // Inicializa los mensajes de las gráficas
            document.getElementById('globalChartStatus').classList.remove('hidden');
            document.getElementById('globalChartStatus').textContent = "Pulsa 'Generar Gráfica de Tipos Global' para ver la distribución.";
            document.getElementById('perRoomChartStatus').classList.remove('hidden');
            document.getElementById('perRoomChartStatus').textContent = "Pulsa 'Generar Gráficas por Salas' para ver la distribución.";
            document.getElementById('satisfactionChartStatus').classList.remove('hidden');
            document.getElementById('satisfactionChartStatus').textContent = "Pulsa 'Generar Gráfica de Satisfacción' para ver los datos.";
            document.getElementById('heatmapStatus').classList.remove('hidden');
            document.getElementById('heatmapStatus').textContent = "Pulsa 'Generar Mapa de Calor' para ver las zonas de mayor permanencia.";
        };


        // --- Función para añadir visitantes por defecto ---
        function addDefaultAgents() {
            // Ejemplo de visitantes por defecto con tipos y colores específicos
            const defaultAgentsData = [
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala1' }, // Red
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala1' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala1' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala1' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala1' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala2' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala1' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala2' },
                { type: 'Visitante 30-64', color: '#169c02', speed: 1.8, behavior: 'random_with_stops', room: 'sala1' }, // Green
                { type: 'Visitante 30-64', color: '#169c02', speed: 1.8, behavior: 'random_with_stops', room: 'sala1' },
                { type: 'Visitante 30-64', color: '#169c02', speed: 1.8, behavior: 'random_with_stops', room: 'sala2' },               
                { type: 'Visitante 30-64', color: '#169c02', speed: 1.8, behavior: 'random_with_stops', room: 'sala2' },
                { type: 'Visitante +65', color: '#0023ef', speed: 1.0, behavior: 'random', room: 'sala1' }, // Blue
                { type: 'Visitante +65', color: '#0023ef', speed: 1.0, behavior: 'random', room: 'sala2' },
                { type: 'Visitante +65', color: '#0023ef', speed: 1.0, behavior: 'random', room: 'sala2' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala5' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala5' },
                { type: 'Visitante +65', color: '#0023ef', speed: 1.0, behavior: 'random', room: 'sala5' },        
                { type: 'Visitante 30-64', color: '#169c02', speed: 1.8, behavior: 'random_with_stops', room: 'sala4' },               
                { type: 'Visitante 30-64', color: '#169c02', speed: 1.8, behavior: 'random_with_stops', room: 'sala4' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala3' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala3' },
                { type: 'Visitante 15-29', color: '#ef0000', speed: 1.5, behavior: 'random_with_stops', room: 'sala3' },
            ];

            defaultAgentsData.forEach(data => {
                agentIdCounter++;
                const newAgent = new Agent(agentIdCounter, data.type, data.color, data.speed, data.behavior, data.room);
                agents.push(newAgent);
            });
            showStatusMessage(`${defaultAgentsData.length} visitantes por defecto añadidos.`);
            updateAgentListUI();
            drawSimulation();
        }

    </script>
</body>
</html>
